#pragma kernel GravitySimulation

//Ideas:

//It might be possible to use a texture2d as a fast 2D storage site to keep track of relationship data between bodies
//This could for example could be made to create a "Who has been close to me for awhile" detection
//Just increase the darkness when close, brightness when far, then just run special code in compute when
//O(1) lookup finds that this particle-particle pair has been together for a hot minute

//By passing in a float2 for mouse pos, and a bool/uint/float2 for the rest of the mouse movement/click data,
//We can add custom movement for planets (Basically all circles within range move), alternatively
//The above method can be used to move only related particles close to mouse.


struct GravityBody {
    float x;
    float y;
    float dx;
    float dy;
    float mass;
    float dense;

    uint id;
};

RWStructuredBuffer<GravityBody> bodyBuffer;
float g;
float distance_scale;
float min_dist;
float drift_power;
float2 drift;
uint numBodies;


float distanceTo(GravityBody p1,GravityBody p2);

float2 pointTowards(GravityBody origin, GravityBody target);


//Gets a point on the surface of the GravityBody origin that points towards target.
float2 pointTowards(GravityBody origin, GravityBody target)
{
    float radius = origin.mass/origin.dense;

    return float2(origin.x,origin.y)+ (normalize(float2(target.x,target.y) - float2(origin.x,origin.y)) * radius);
}


float distanceTo(GravityBody p1,GravityBody p2)
{
   float2 pos1=pointTowards(p1,p2);
   float2 pos2=pointTowards(p2,p1);

   float distX = abs(pos2.x - pos1.x);
   float distY = abs(pos2.y - pos1.y);
   return(sqrt(distX*distX + distY*distY));
}

[numthreads(8, 8, 1)]
void GravitySimulation (uint3 id : SV_DispatchThreadID)
{
    //Loop through each x,y combination possible between any planet x and another planet y.
    uint index1 = id.x;
    uint index2=id.y;


    if(index1 >= numBodies || index2 >= numBodies)
    {
    //Dont do anything if we are only here because the number of bodies % 8 != 0
    }
    //Root out when x==y, (we dont want self gravitation)
    else if (index1!=index2)
    {
        
        GravityBody body1=bodyBuffer[index1];
        GravityBody body2=bodyBuffer[index2];
        float dist=max(min_dist,distanceTo(body1,body2)/distance_scale);


        
        //F= ma, so a= F/m (we can remove our mass from gravity calculation)
        float acceleration= (body2.mass*g)/(dist*dist);
    
        float2 dir =-normalize(float2(body1.x-body2.x,body1.y-body2.y));

        
        
        body1.dx+=(acceleration)*dir.x;
        body1.dy+=(acceleration)*dir.y;

        if (abs(drift_power)>0.01)
        {
            //Calculate drift here:
            acceleration= drift_power/numBodies;
            dir =-normalize(float2(body1.x-drift.x,body1.y-drift.y));
            body1.dx+=acceleration*dir.x;
            body1.dy+=acceleration*dir.y;
            //
        }

        bodyBuffer[index1]=body1;
        //We only calculate for x's attraction to y here, y will calculate its attraction to x another time.
    
    }
}
